let s:pluglist = string(g:plugins)

function! s:findplug(plugname)
    return stridx(s:pluglist, a:plugname)
endfunction


"{{{
if (s:findplug('vim-indent-guides') != -1)
    let g:indent_guides_enable_on_vim_startup=0
    let g:indent_guides_start_level=2
    let g:indent_guides_guide_size=1
    :nmap <silent> <Leader>i <Plug>IndentGuidesToggle
endif
"}}}


"{{{
if (s:findplug('gen_tags.vim') != -1)
    nmap <silent> <Leader>gt :call Fcy_gen_tags(1)<CR>
    nmap <silent> <Leader>ct :call Fcy_gen_tags(0)<CR>
    function! Fcy_gen_tags(value)
        if a:value == 1
            GenCtags
            GenGTAGS
            echon "gen tags end"
        else
            let l:cmd = 'ClearCtags!'
            exe l:cmd
            echon "clear tags end"
        endif
    endfunction
endif
"}}}


"{{{
if (s:findplug('lightline') != -1)
    set showtabline=1 
    "let g:lightline = {'colorscheme': 'default'}
    let g:lightline = {'colorscheme': 'solarized'}
    let g:lightline.enable = {
        \ 'statusline': 1,
        \ 'tabline': 1
        \ }
    noremap <silent><leader>tc :tabnew<cr>
    noremap <silent><leader>tq :tabclose<cr>
    noremap <silent><leader>tn :tabn<cr>
    noremap <silent><leader>tp :tabp<cr>
    noremap <silent><leader>1 :tabn 1<cr>
    noremap <silent><leader>2 :tabn 2<cr>
    noremap <silent><leader>3 :tabn 3<cr>
    noremap <silent><leader>4 :tabn 4<cr>
    noremap <silent><leader>5 :tabn 5<cr>
    noremap <silent><leader>6 :tabn 6<cr>
    noremap <silent><leader>7 :tabn 7<cr>
    noremap <silent><leader>8 :tabn 8<cr>
    noremap <silent><leader>9 :tabn 9<cr>
    noremap <silent><leader>0 :tabn 10<cr>
    noremap <silent><s-tab> :tabnext<CR>
    inoremap <silent><s-tab> <ESC>:tabnext<CR>
endif
"}}}


"{{{
if (s:findplug('vim-expand-region') != -1)
    xmap v <Plug>(expand_region_expand)
    xmap V <Plug>(expand_region_shrink)
    let g:expand_region_text_objects = {
          \ 'iw'  :0,
          \ 'iW'  :0,
          \ 'i"'  :0,
          \ 'i''' :0,
          \ 'i]'  :1,
          \ 'ib'  :1,
          \ 'iB'  :1,
          \ 'il'  :1,
          \ 'ii'  :1,
          \ 'ip'  :0,
          \ 'ie'  :0,
          \ }
endif
"}}}


"{{{
if (s:findplug('gina') != -1)
    nnoremap <silent> <leader>gst    :Gina status<CR>
    nnoremap <silent> <leader>gU     :Gina reset -q %<CR>
    nnoremap <silent> <leader>gca    :Gina commit -a<CR>
    nnoremap <silent> <leader>gcam   :Gina commit -a --amend<CR>
    nnoremap <silent> <leader>gd     :Gina diff<CR>
    nnoremap <silent> <leader>gp     :Gina push<CR>
    nnoremap <silent> <leader>ga     :Gina add %<CR>
    nnoremap <silent> <leader>gA     :Gina add .<CR>
    nnoremap <silent> <leader>gl     :Gina pull<CR>
    nnoremap <silent> <leader>glg    :Gina log<CR>
    nnoremap <silent> <leader>gb     :Gina blame<CR>
endif
"}}}


"{{{
if (s:findplug('LanguageClient-neovim') != -1)
    nnoremap <silent> K :call LanguageClient_textDocument_hover()<CR>
    nnoremap <silent> gd :call LanguageClient_textDocument_definition()<CR>
    nnoremap <silent> <F2> :call LanguageClient_textDocument_rename()<CR>
    set hidden
    let g:LanguageClient_autoStart = 1
    let g:LanguageClient_serverCommands = {
                \ 'c': ['clangd'],
                \ 'cpp': ['clangd']
                \ }
endif
"}}}


"{{{
if (s:findplug('deoplete') != -1)
    let g:deoplete#enable_at_startup = 1
    let g:deoplete#enable_smart_case = 1

    "let g:deoplete#sources.c = ['buffer', 'tag']
    "
    " <C-h>, <BS>: close popup and delete backword char.
    inoremap <expr><C-h> deoplete#smart_close_popup()."\<C-h>"
    "inoremap <expr><BS>  deoplete#smart_close_popup()."\<C-h>"

    " <CR>: close popup and save indent.
    inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
    function! s:my_cr_function() abort
        return deoplete#close_popup() . "\<CR>"
    endfunction

    "set completeopt=menu,longest       "menu longest noinsert preview
endif
"}}}


"{{{
if (s:findplug('vim-multiple-cursors') != -1)
    "let g:multi_cursor_next_key='<S-n>'
    "let g:multi_cursor_prev_key='<S-p>'
    "let g:multi_cursor_skip_key='<S-x>'
    let g:multi_cursor_quit_key='<Esc>'
    " Called once right before you start selecting multiple cursors
    function! Multiple_cursors_before()
        if exists(':NeoCompleteLock')==2
            exe 'NeoCompleteLock'
        endif
    endfunction

    " Called once only when the multiple selection is canceled (default <Esc>)
    function! Multiple_cursors_after()
        if exists(':NeoCompleteUnlock')==2
            exe 'NeoCompleteUnlock'
        endif
        let g:deoplete#disable_auto_complete = 0
    endfunction

    function! g:Multiple_cursors_before()
        let g:deoplete#disable_auto_complete = 1
    endfunction
endif
"}}}


"{{{
if (s:findplug('nerdtree') != -1)
    nmap <leader>nt :NERDTreeToggle<cr>
    nmap <F12> :NERDTreeToggle<cr>
    let NERDTreeWinSize=32
    let NERDTreeWinPos="right"
    let NERDTreeShowHidden=1
    let NERDTreeMinimalUI=1
    let NERDTreeAutoDeleteBuffer=1
    let NERDTreeShowBookmarks=1
    let NERDTreeShowLineNumbers=1
    let NERDTreeShowHidden=1

    let NERDTreeIgnore=['GPATH', 'tags', 'GRTAGS', 'GTAGS', 'GSYMS', '\~$']
endif
"}}}


"{{{
if (s:findplug('ctrlsf') != -1)
    "let g:ctrlsf_debug_mode = 1
    "redir! > ctrlsf.log
    let g:ctrlsf_ackprg = 'rg'
    let g:ctrlsf_regex_pattern = 1
    let g:ctrlsf_case_sensitive = 'smart'
    let g:ctrlsf_ignore_dir = ['tags', 'GTAGS', 'GPATH', 'GRTAGS', 'obj', 'out', 'Out']

    nmap <leader>sf <Plug>CtrlSFCwordExec
    nmap <leader>sF <Plug>CtrlSFPrompt
    vmap <leader>sf <Plug>CtrlSFVwordExec
    vmap <leader>sF <Plug>CtrlSFVwordPath
    nmap <leader>sp <Plug>CtrlSFPwordPath
    nnoremap <leader>so :CtrlSFOpen<CR>
    nnoremap <leader>st :CtrlSFToggle<CR>
    inoremap <leader>st <Esc>:CtrlSFToggle<CR>

    let g:ctrlsf_mapping = {
        \ "next"    : "<c-w>",
        \ "prev"    : "<c-e>",
        \ }

    autocmd! FileType ctrlsf call s:ctrlsf_settings()
    function! s:ctrlsf_settings()
        nmap <buffer> <c-j> <c-w>p
        nmap <buffer> <c-k> <c-e>p
    endfunction
endif
"}}}


"{{{
if (s:findplug('vim-session') != -1)
    let g:session_autosave = 'no'
    let g:session_autoload = 'no'    
endif
"}}}


"{{{
if (s:findplug('LeaderF') != -1)
    let g:Lf_CommandMap = {'<C-C>': ['<Esc>'],'<Esc>':['<C-I>']}
    let g:Lf_PreviewCode = 0
    let g:Lf_DefaultMode = 'FullPath'
    let g:Lf_WildIgnore = {
           \ 'dir': ['.svn','.git','.hg'],
           \ 'file': ['*.sw?','~$*','*.bak','*.exe','*.o','*.so','*.py[co]']
           \}

    nnoremap ff :<C-u>LeaderfFile<CR>
    nnoremap fb :<C-u>LeaderfBuffer<CR>
    nnoremap fl :<C-u>LeaderfLine<CR>
    nnoremap fo :<C-u>LeaderfFunction<CR>
    nnoremap ft :<C-u>LeaderfTag<CR>
    nnoremap fm :<C-u>LeaderfMru<CR>
    nnoremap fh :<C-u>LeaderfHistorySearch<CR>
    nnoremap fg :<C-u>CtrlSF 
endif
"}}}


"{{{
if (s:findplug('neocomplete') != -1)
    let g:neocomplete#data_directory= g:config_dir . '/.cache/neocomplete'
    let g:acp_enableAtStartup = 0
    let g:neocomplete#enable_at_startup = 1
    " Use smartcase.
    let g:neocomplete#enable_smart_case = 1
    let g:neocomplete#enable_camel_case = 1
    "let g:neocomplete#enable_ignore_case = 1
    let g:neocomplete#enable_fuzzy_completion = 1
    " Set minimum syntax keyword length.
    let g:neocomplete#sources#syntax#min_keyword_length = 3
    let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'

    " Define dictionary.
    let g:neocomplete#sources#dictionary#dictionaries =
          \ {
          \ 'default' : '',
          \ 'vimshell' : g:config_dir . '/.cache/vimshell/command-history',
          \ 'java' : g:config_dir . '/.cache/dict/java.dict',
          \ 'ruby' : g:config_dir . '/.cache/dict/ruby.dict',
          \ 'scala' : g:config_dir . '/.cache/dict/scala.dict',
          \ }

    let g:neocomplete#enable_auto_delimiter = 1

    " neco-vim
    if !exists('g:necovim#complete_functions')
        let g:necovim#complete_functions = {}
    endif
    let g:necovim#complete_functions.Ref =
                \ 'ref#complete'

    " Define keyword.
    if !exists('g:neocomplete#keyword_patterns')
      let g:neocomplete#keyword_patterns = {}
    endif
    let g:neocomplete#keyword_patterns._ =
          \ get(g:neocomplete#keyword_patterns, '_', '\h\k*(\?')

    " AutoComplPop like behavior.
    let g:neocomplete#enable_auto_select = 0

    if !exists('g:neocomplete#sources#omni#input_patterns')
      let g:neocomplete#sources#omni#input_patterns = {}
    endif

    let g:neocomplete#sources#omni#input_patterns.perl =
          \ get(g:neocomplete#sources#omni#input_patterns, 'perl',
          \ '\h\w*->\h\w*\|\h\w*::')
    let g:neocomplete#sources#omni#input_patterns.java =
          \ get(g:neocomplete#sources#omni#input_patterns, 'java',
          \ '[^. \t0-9]\.\w*')
    let g:neocomplete#sources#omni#input_patterns.lua =
          \ get(g:neocomplete#sources#omni#input_patterns, 'lua',
          \ '[^. \t0-9]\.\w*')
    let g:neocomplete#sources#omni#input_patterns.c =
          \ get(g:neocomplete#sources#omni#input_patterns, 'c',
          \ '[^.[:digit:] *\t]\%(\.\|->\)')
    let g:neocomplete#sources#omni#input_patterns.cpp =
          \ get(g:neocomplete#sources#omni#input_patterns, 'cpp',
          \ '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::')
    if !exists('g:neocomplete#force_omni_input_patterns')
      let g:neocomplete#force_omni_input_patterns = {}
    endif
    "let g:neocomplete#force_omni_input_patterns.java = '^\s*'

    " <C-h>, <BS>: close popup and delete backword char.
    "inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
    "inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
    inoremap <expr><C-y>  neocomplete#close_popup()
    inoremap <expr><C-e>  neocomplete#cancel_popup()
    inoremap <expr><C-l>  neocomplete#start_manual_complete()
    inoremap <expr><C-x><c-u>  neocomplete#start_manual_complete()

    " <CR>: close popup and save indent.
    inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
    function! s:my_cr_function()
      return (pumvisible() ? "\<C-y>" : "" ) . "\<CR>"
      " For no inserting <CR> key.
      "return pumvisible() ? "\<C-y>" : "\<CR>"
    endfunction
    " <TAB>: completion.
    inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
    inoremap <expr><S-TAB>  pumvisible() ? "\<C-p>" : "\<TAB>"

    set completeopt=menu,longest       "menu longest noinsert preview

    " vim:set et sw=2

endif
"}}}


"{{{
if (s:findplug('denite') != -1)
    if executable('rg')
        call denite#custom#var('grep', 'command', ['rg'])
        call denite#custom#var('file_rec', 'command',
            \ ['rg', '--files', '--hidden', '--follow',
            \ '-g','!out', '-g','!obj', '-g', '!deploy',
            \ '-g','!tags', '-g','!GTAGS', '-g','!GRTAGS', '-g','!GPATH',
            \ '-g', '!.git', '-g', '!.svn'])
        call denite#custom#var('grep', 'default_opts',
            \ ['--vimgrep', '--no-heading'])
        call denite#custom#var('grep', 'recursive_opts', [])
        call denite#custom#var('grep', 'pattern_opt', ['--regexp'])
        call denite#custom#var('grep', 'separator', ['--'])
        call denite#custom#var('grep', 'final_opts', [])
    elseif executable('pt')
        call denite#custom#var('grep', 'command', ['pt'])
        call denite#custom#var('file_rec', 'command',
            \ ['pt', '--follow', '--nocolor', '--nogroup', '--hidden',
            \ '--ignore','lib', '--ignore','obj', '--ignore','out',
            \ '--ignore','deploy',
            \ '--ignore','tags', '--ignore','GTAGS', '--ignore','GRTAGS', '--ignore','GPATH',
            \ '--ignore','.git', '--ignore','.svn', '-g', ''])
        call denite#custom#var('grep', 'default_opts',
            \ ['--nogroup', '--nocolor', '--smart-case', '--hidden',
            \ '--ignore','lib', '--ignore','obj', '--ignore','out',
            \ '--ignore','deploy',
            \ '--ignore','tags', '--ignore','GTAGS', '--ignore','GRTAGS', '--ignore','GPATH',
            \ '--ignore','.git', '--ignore','.svn'])
        call denite#custom#var('grep', 'recursive_opts', [])
        call denite#custom#var('grep', 'pattern_opt', [])
        call denite#custom#var('grep', 'separator', ['--'])
        call denite#custom#var('grep', 'final_opts', [])
    endif

    call denite#custom#filter('matcher_ignore_globs', 'ignore_globs',
        \ [ '.git/', '.ropeproject/', '__pycache__/',
        \ 'venv/', 'images/', '*.min.*', 'img/', 'fonts/'])

    call denite#custom#source('file_mru', 'converters',
        \ ['converter_relative_word'])
        
    " Change matchers.
    call denite#custom#source('file_mru', 'matchers', ['matcher_fuzzy', 'matcher_project_files'])
    "call denite#custom#source('file_rec', 'matchers', ['matcher_cpsm'])

    " Change sorters.
    call denite#custom#source('file_rec', 'sorters', ['sorter_sublime'])  

    nnoremap [Denite] <Nop>
    nmap f [Denite]
    nmap <c-p> [Denite]
    nnoremap [Denite]f :<C-u>Denite file_rec<CR>
    "nnoremap [Denite]f :<C-u>FZF<CR>
    nnoremap [Denite]F :<C-u>Denite file_rec
    nnoremap [Denite]b :<C-u>Denite buffer bookmark<CR>
    nnoremap [Denite]g :<C-u>Denite grep:.<CR>
    nnoremap [Denite]l :<C-u>Denite line<CR>
    nnoremap [Denite]o :<C-u>Denite outline<CR>
    nnoremap [Denite]h :<C-u>Denite history/yank<CR>
    nnoremap [Denite]m :<C-u>Denite file_mru<CR>
    nnoremap [Denite]p :<C-u>Denite jump_point file_point<CR>
    "nnoremap [Denite]s :<C-u>Denite source<CR>

    " KEY MAPPINGS
    let s:insert_mode_mappings = [
            \ ['<Tab>', '<denite:move_to_next_line>', 'noremap'],
            \ ['<S-tab>', '<denite:move_to_previous_line>', 'noremap'],
            \ ['<C-j>', '<denite:move_to_next_line>', 'noremap'],
            \ ['<C-k>', '<denite:move_to_previous_line>', 'noremap'],
            \ ['<C-t>', '<denite:move_to_first_line>', 'noremap'],
            \ ['<C-b>', '<denite:move_to_last_line>', 'noremap'],
            \ ]

    let s:normal_mode_mappings = [
            \ ["'", '<denite:toggle_select_down>', 'noremap'],
            \ ['<C-t>', '<denite:move_to_first_line>', 'noremap'],
            \ ['<C-b>', '<denite:move_to_last_line>', 'noremap'],
            \ ['st', '<denite:do_action:tabopen>', 'noremap'],
            \ ['sh', '<denite:do_action:vsplit>', 'noremap'],
            \ ['sv', '<denite:do_action:split>', 'noremap'],
            \ ]

    for s:m in s:insert_mode_mappings
        call denite#custom#map('insert', s:m[0], s:m[1], s:m[2])
    endfor
    for s:m in s:normal_mode_mappings
        call denite#custom#map('normal', s:m[0], s:m[1], s:m[2])
    endfor

    unlet s:m s:insert_mode_mappings s:normal_mode_mappings
endif
"}}}


"{{{
if (s:findplug('vim-choosewin') != -1)
    nmap - <Plug>(choosewin)
endif
"}}}


"{{{
if (s:findplug('unite') != -1)
    let g:unite_data_directory=g:config_dir . '/.cache/unite'
    let g:unite_enable_start_insert=0
    let g:unite_source_history_yank_enable = 1
    let g:unite_force_overwrite_statusline=1

    call unite#filters#matcher_default#use(['matcher_fuzzy'])

    if g:os_windows
        if executable('ag')
            let g:unite_source_rec_async_command = [
            \ 'ag', '--follow', '--nocolor', '--nogroup', '--hidden',
            \ '--ignore','lib', '--ignore','obj', '--ignore','out',
            \ '--ignore','tags', '--ignore','GTAGS', '--ignore','GRTAGS', '--ignore','GPATH',
            \ '--ignore','deploy',
            \ '-g', '']
        elseif executable('pt')
            let g:unite_source_rec_async_command = [
            \ 'pt', '--follow', '--nocolor', '--nogroup', '--hidden',
            \ '--ignore','lib', '--ignore','obj', '--ignore','out',
            \ '--ignore','tags', '--ignore','GTAGS', '--ignore','GRTAGS', '--ignore','GPATH',
            \ '--ignore','deploy',
            \ '-g:', '']
        endif
    endif

    if executable('pt')
        if g:os_linux
            let g:unite_source_rec_async_command = [
            \ 'pt', '--follow', '--nocolor', '--nogroup', '--hidden',
            \ '--ignore','lib', '--ignore','obj', '--ignore','out',
            \ '--ignore','tags', '--ignore','GTAGS', '--ignore','GRTAGS', '--ignore','GPATH',
            \ '--ignore','deploy',
            \ '-g', '']
        endif

        let g:unite_source_grep_command = 'pt'
        let g:unite_source_grep_default_opts =
        \'--vimgrep --hidden --nocolor --nogroup
        \ --ignore ''.svn'' --ignore ''.git''
        \ --ignore ''lib'' --ignore ''obj'' --ignore ''out''
        \ --ignore ''tags'' --ignore ''GTAGS'' --ignore ''GRTAGS'' --ignore ''GPATH''
        \ --ignore ''deploy''
        \'
    endif
    let g:unite_source_grep_encoding = 'utf-8'

    nnoremap [unite] <Nop>
    nmap f [unite]
    nmap <c-p> [unite]
    "nnoremap <silent> [unite]s :<C-u>Unite source<CR>
    nnoremap <silent> [unite]f :<C-u>Unite -silent -start-insert file_rec/async<CR>
    nnoremap <silent> [unite]b :<C-u>Unite -start-insert buffer bookmark<CR>
    nnoremap <silent> [unite]g :<C-u>Unite grep:.<CR>
    nnoremap <silent> [unite]l :<C-u>Unite -start-insert line<CR>
    nnoremap <silent> [unite]o :<C-u>Unite -start-insert outline<CR>
    nnoremap <silent> [unite]y :<C-u>Unite history/yank<CR>
    nnoremap <silent> [unite]h :<C-u>Unite file_mru<CR>
    nnoremap <silent> [unite]p :<C-u>Unite jump_point file_point<CR>
    nnoremap <silent> [unite]r <Plug>(unite_redraw)

    autocmd FileType unite call s:unite_my_settings()
    function! s:unite_my_settings()
        let b:SuperTabDisabled=1
        imap <buffer> <C-j>     <Plug>(unite_select_next_line)
        nmap <buffer> <C-j>     <Plug>(unite_select_next_line)
        imap <buffer> <C-k>     <Plug>(unite_select_previous_line)
        nmap <buffer> <C-k>     <Plug>(unite_select_previous_line)
        
        imap <buffer> <TAB>     <Plug>(unite_select_next_line)
        imap <buffer> <C-w>     <Plug>(unite_delete_backward_path)
        imap <buffer> '         <Plug>(unite_quick_match_default_action)
        nmap <buffer> '         <Plug>(unite_quick_match_default_action) 
        imap <buffer><expr> x
                \ unite#smart_map('x', "\<Plug>(unite_quick_match_choose_action)")    
        nmap <buffer> <C-z>     <Plug>(unite_toggle_transpose_window)
        imap <buffer> <C-z>     <Plug>(unite_toggle_transpose_window)
        nmap <buffer> <C-p>     <Plug>(unite_toggle_auto_preview)
        imap <buffer> <C-p>     <Plug>(unite_toggle_auto_preview)
        nmap <buffer> <C-r>     <Plug>(unite_narrowing_input_history)
        imap <buffer> <C-r>     <Plug>(unite_narrowing_input_history)
        nmap <buffer> <esc>     <plug>(unite_exit)
        imap <buffer> <esc>     <plug>(unite_exit)
    endfunction
    
    "unite-gtags
    "nnoremap <leader>gd :execute 'Unite  -auto-preview -start-insert -no-split gtags/def:'.expand('<cword>')<CR>
    "nnoremap <leader>gc :execute 'Unite  -auto-preview -start-insert -no-split gtags/context'<CR>
    nnoremap <leader>gr :execute 'Unite  -auto-preview -start-insert -no-split gtags/ref'<CR>
    nnoremap <leader>gg :execute 'Unite  -auto-preview -start-insert -no-split gtags/grep'<CR>
    "nnoremap <leader>gp :execute 'Unite  -auto-preview -start-insert -no-split gtags/completion'<CR>
    vnoremap <leader>gd <ESC>:execute 'Unite -auto-preview -start-insert -no-split gtags/def:'.GetVisualSelection()<CR>
    let g:unite_source_gtags_project_config = get(g:, 'unite_source_gtags_project_config', {
          \ '_':                   { 'treelize': 0 }
          \ })
endif
"}}}


"{{{
if (s:findplug('vim-bookmarks') != -1)
    nmap <Leader>m <Plug>BookmarkToggle
    nmap <Leader>mi <Plug>BookmarkAnnotate
    nmap <Leader>ma <Plug>BookmarkShowAll
    nmap <Leader>mj <Plug>BookmarkNext
    nmap <Leader>mk <Plug>BookmarkPrev 
    nmap <Leader>mc <Plug>BookmarkClear 
    nmap <Leader>mx <Plug>BookmarkClearAll
endif
"}}}


"{{{
if (s:findplug('vim-ref') != -1)
    let g:ref_source_webdict_sites = {
          \   'je': {
          \     'url': 'http://dictionary.infoseek.ne.jp/jeword/%s',
          \   },
          \   'ej': {
          \     'url': 'http://dictionary.infoseek.ne.jp/ejword/%s',
          \   },
          \   'wiki': {
          \     'url': 'http://ja.wikipedia.org/wiki/%s',
          \   },
          \   'cn': {
          \     'url': 'http://www.iciba.com/%s',
          \   },
          \   'wikipedia:en':{'url': 'http://en.wikipedia.org/wiki/%s',  },
          \   'bing':{'url': 'http://cn.bing.com/search?q=%s', },
          \ }
    let g:ref_source_webdict_sites.default = 'cn'
    "let g:ref_source_webdict_cmd='lynx -dump -nonumbers %s'
    "let g:ref_source_webdict_cmd='w3m -dump %s'
    "The filter on the output. Remove the first few lines
    function! g:ref_source_webdict_sites.je.filter(output)
      return join(split(a:output, "\n")[15 :], "\n")
    endfunction
    function! g:ref_source_webdict_sites.ej.filter(output)
      return join(split(a:output, "\n")[15 :], "\n")
    endfunction
    function! g:ref_source_webdict_sites.wiki.filter(output)
      return join(split(a:output, "\n")[17 :], "\n")
    endfunction
    nnoremap <Leader>rj :<C-u>Ref webdict je<Space>
    nnoremap <Leader>re :<C-u>Ref webdict ej<Space>
    nnoremap <Leader>rc :<C-u>Ref webdict cn<Space>
    nnoremap <Leader>rw :<C-u>Ref webdict wikipedia:en<Space>
    nnoremap <Leader>rb :<C-u>Ref webdict bing<Space>
endif
"}}}


"{{{
if (s:findplug('fencview') != -1)
    let g:fencview_autodetect = 1
    let g:fencview_checklines = 10
endif
"}}}


"{{{
if (s:findplug('gocode') != -1)
    "start gocode first
    function! s:fcy_CallGocode()
        if !exists('g:startGocode')
            call vimproc#system_bg('gocode')
            let g:startGocode = 1
        endif
    endfunction
    autocmd! VimEnter *.go call s:fcy_CallGocode()

    "let g:gocomplete#system_function = 'vimproc#system'
    let g:godef_split=0
    let g:godef_same_file_in_same_window=1
endif
"}}}


"{{{
if (s:findplug('nerdcommenter') != -1)
    let g:NERDCreateDefaultMappings = 0
    let g:NERDRemoveExtraSpaces = 1
    let g:NERDDefaultAlign = 'left'
    let g:NERDCustomDelimiters = {
                \ 'c': { 'leftAlt': '/*', 'rightAlt': '*/', 'left': '//' },
                \ 'cpp': { 'leftAlt': '/*', 'rightAlt': '*/', 'left': '//' },
                \ 'go': { 'leftAlt': '/*', 'rightAlt': '*/', 'left': '//' },
                \ 'qml': { 'leftAlt': '/*', 'rightAlt': '*/', 'left': '//' },
                \ 'conf': { 'leftAlt': '/*', 'rightAlt': '*/', 'left': '#' },
                \ }
    nmap <A-/> <plug>NERDCommenterToggle
    vmap <A-/> <plug>NERDCommenterToggle gv
    nmap <leader>cc <plug>NERDCommenterToggle
    vmap <leader>cc <plug>NERDCommenterToggle gv
endif
"}}}


"{{{
if (s:findplug('tagbar') != -1)
    let tagbar_left=1
    nnoremap <silent><Leader>tt :TagbarToggle<CR>
    nnoremap <silent><F11> :TagbarToggle<CR>
    let tagbar_width=32
    let g:tagbar_compact=1
    "autocmd FileType c,cpp,h nested :TagbarOpen
    let g:tagbar_type_go = {
    \ 'ctagstype' : 'go',
    \ 'kinds'     : [
        \ 'p:package',
        \ 'i:imports:1',
        \ 'c:constants',
        \ 'v:variables',
        \ 't:types',
        \ 'n:interfaces',
        \ 'w:fields',
        \ 'e:embedded',
        \ 'm:methods',
        \ 'r:constructor',
        \ 'f:functions'
    \ ],
    \ 'sro' : '.',
    \ 'kind2scope' : {
        \ 't' : 'ctype',
        \ 'n' : 'ntype'
    \ },
    \ 'scope2kind' : {
        \ 'ctype' : 't',
        \ 'ntype' : 'n'
    \ },
    \ 'ctagsbin'  : 'gotags',
    \ 'ctagsargs' : '-sort -silent'
    \ }
endif
"}}}


"{{{
if (s:findplug('vim-bbye') != -1)
    :nnoremap <Leader>q :Bdelete<CR>
endif
"}}}


"{{{
if (s:findplug('vim-easymotion') != -1)
    let g:EasyMotion_smartcase = 0
    let g:EasyMotion_do_mapping = 0 " Disable default mappings
    nmap <leader>jj <Plug>(easymotion-s)
    nmap <leader>jJ <Plug>(easymotion-s2)
    nmap <leader>jl <Plug>(easymotion-bd-jk)
    nmap <leader>jw <Plug>(easymotion-bd-w)
endif
"}}}


"{{{
if (s:findplug('vim-fswitch') != -1)
    map <silent> <Leader>h <ESC>:FSHere<CR>
endif
"}}}


"{{{
if (s:findplug('vimshell') != -1)
    nnoremap <leader>vs :silent VimShell<CR>
    let g:vimshell_prompt_expr =
        \ 'escape(fnamemodify(getcwd(), ":~").">", "\\[]()?! ")." "'
    let g:vimshell_prompt_pattern = '^\%(\f\|\\.\)\+> '
    let g:vimshell_no_default_keymappings=0
endif
"}}}



"{{{
if (s:findplug('vim-AHKcomplete') != -1)
    " Enable omni completion.
    autocmd FileType autohotkey setl omnifunc=ahkcomplete#Complete
endif
"}}}
